"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function() {
        return _default;
    }
});
var _necessary = require("necessary");
var _easy = require("easy");
var _constants = require("../constants");
var _reference = require("../utilities/reference");
var _event = require("../utilities/event");
var _eventTypes = require("../eventTypes");
function _array_like_to_array(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];
    return arr2;
}
function _array_without_holes(arr) {
    if (Array.isArray(arr)) return _array_like_to_array(arr);
}
function _iterable_to_array(iter) {
    if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}
function _non_iterable_spread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _to_consumable_array(arr) {
    return _array_without_holes(arr) || _iterable_to_array(arr) || _unsupported_iterable_to_array(arr) || _non_iterable_spread();
}
function _unsupported_iterable_to_array(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _array_like_to_array(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(n);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _array_like_to_array(o, minLen);
}
var forEach = _necessary.asynchronousUtilities.forEach, ESCAPE_KEY_CODE = _necessary.keyCodes.ESCAPE_KEY_CODE, BLUR_EVENT_TYPE = _easy.eventTypes.BLUR_EVENT_TYPE, LEFT_MOUSE_BUTTON = _easy.mouseButtons.LEFT_MOUSE_BUTTON;
var dragElement = null;
Object.assign(globalThis, {
    dragElement: dragElement
});
function onDrag(dragHandler, element) {
    var eventType = _eventTypes.DRAG_EVENT_TYPE, handler = dragHandler; ///
    this.addEventListener(eventType, handler, element);
}
function offDrag(dragHandler, element) {
    var eventType = _eventTypes.DRAG_EVENT_TYPE, handler = dragHandler; ///
    this.removeEventListener(eventType, handler, element);
}
function onStopDrag(stopDragHandler, element) {
    var eventType = _eventTypes.STOP_DRAG_EVENT_TYPE, handler = stopDragHandler; ///
    this.addEventListener(eventType, handler, element);
}
function offStopDrag(stopDragHandler, element) {
    var eventType = _eventTypes.STOP_DRAG_EVENT_TYPE, handler = stopDragHandler; ///
    this.removeEventListener(eventType, handler, element);
}
function onStartDrag(startDragHandler, element) {
    var eventType = _eventTypes.START_DRAG_EVENT_TYPE, handler = startDragHandler; ///
    this.addEventListener(eventType, handler, element);
}
function offStartDrag(startDragHandler, element) {
    var eventType = _eventTypes.START_DRAG_EVENT_TYPE, handler = startDragHandler; ///
    this.removeEventListener(eventType, handler, element);
}
function enableDrag() {
    var _this_properties = this.properties, _$onDrag = _this_properties.onDrag, _$onStopDrag = _this_properties.onStopDrag, _$onStartDrag = _this_properties.onStartDrag, dragHandler = _$onDrag, stopDragHandler = _$onStopDrag, startDragHandler = _$onStartDrag, timeout = null, topOffset = null, leftOffset = null, startMouseTop = null, startMouseLeft = null;
    dragHandler && this.onDrag(dragHandler);
    stopDragHandler && this.onStopDrag(stopDragHandler);
    startDragHandler && this.onStartDrag(startDragHandler);
    this.onMouseDown(mouseDownHandler, this);
    this.setState({
        timeout: timeout,
        topOffset: topOffset,
        leftOffset: leftOffset,
        startMouseTop: startMouseTop,
        startMouseLeft: startMouseLeft
    });
}
function disableDrag() {
    var _this_properties = this.properties, _$onDrag = _this_properties.onDrag, _$onStopDrag = _this_properties.onStopDrag, _$onStartDrag = _this_properties.onStartDrag, dragHandler = _$onDrag, stopDragHandler = _$onStopDrag, startDragHandler = _$onStartDrag; ///
    dragHandler && this.offDrag(dragHandler);
    stopDragHandler && this.offStopDrag(stopDragHandler);
    startDragHandler && this.offStartDrag(startDragHandler);
    this.offMouseDown(mouseDownHandler, this);
}
function isDragging() {
    var dragging = this.hasClass("dragging");
    return dragging;
}
function startWaitingToDrag(mouseTop, mouseLeft) {
    var _this = this;
    var timeout = this.getTimeout();
    if (timeout === null) {
        timeout = setTimeout(function() {
            _this.resetTimeout();
            _this.startDrag(mouseTop, mouseLeft);
        }, _constants.START_DRAGGING_DELAY);
        this.updateTimeout(timeout);
    }
}
function stopWaitingToDrag() {
    var timeout = this.getTimeout();
    if (timeout !== null) {
        clearTimeout(timeout);
        this.resetTimeout();
    }
}
function startDrag(mouseTop, mouseLeft) {
    var bounds = this.getBounds(), eventType = _eventTypes.START_DRAG_EVENT_TYPE, boundsTop = bounds.getTop(), boundsLeft = bounds.getLeft(), boundsRight = bounds.getRight(), boundsBottom = bounds.getBottom(), boundsWidth = boundsRight - boundsLeft, boundsHeight = boundsBottom - boundsTop, topOffset = Math.floor(boundsHeight / 2), leftOffset = Math.floor(boundsWidth / 2), dragElement = this, startMouseTop = mouseTop, startMouseLeft = mouseLeft; ///
    _easy.window.onKeyDown(keyDownHandler, this);
    _easy.window.onMouseMove(mouseMoveHandler, this);
    this.addClass("dragging");
    Object.assign(globalThis, {
        dragElement: dragElement
    });
    this.setTopOffset(topOffset);
    this.setLeftOffset(leftOffset);
    this.setStartMouseTop(startMouseTop);
    this.setStartMouseLeft(startMouseLeft);
    this.callHandlers(eventType);
    this.drag(mouseTop, mouseLeft);
}
function stopDrag(aborted) {
    var _this = this;
    var dropElement = globalThis.dropElement, eventType = _eventTypes.STOP_DRAG_EVENT_TYPE;
    _easy.window.offKeyDown(keyDownHandler, this);
    _easy.window.offMouseMove(mouseMoveHandler, this);
    var done = function() {
        _this.callHandlersAsync(eventType, dropElement, aborted, function() {
            var dragElement = null;
            Object.assign(globalThis, {
                dragElement: dragElement
            });
            _this.removeClass("dragging");
        });
    };
    if (dropElement !== null) {
        var dragElement = this; ///
        var dragElementIgnoresDropElement = (0, _reference.checkDragElementIgnoresDropElement)(dragElement, dropElement);
        if (dragElementIgnoresDropElement) {
            dragElement = null;
        }
        dropElement.drop(dragElement, aborted, done);
    } else {
        done();
    }
}
function drag(mouseTop, mouseLeft) {
    var eventType = _eventTypes.DRAG_EVENT_TYPE, scrollTop = _easy.window.getScrollTop(), scrollLeft = _easy.window.getScrollLeft(), topOffset = this.getTopOffset(), leftOffset = this.getLeftOffset(), startMouseTop = this.getStartMouseTop(), startMouseLeft = this.getStartMouseLeft(), relativeMouseTop = mouseTop - startMouseTop, relativeMouseLeft = mouseLeft - startMouseLeft;
    var top = startMouseTop + relativeMouseTop - topOffset - scrollTop, left = startMouseLeft + relativeMouseLeft - leftOffset - scrollLeft;
    top = "".concat(top, "px"); ///
    left = "".concat(left, "px"); ///
    var css = {
        top: top,
        left: left
    };
    this.css(css);
    this.callHandlers(eventType, relativeMouseTop, relativeMouseLeft);
}
function getTimeout() {
    var timeout = this.getState().timeout;
    return timeout;
}
function resetTimeout() {
    var timeout = null;
    this.updateTimeout(timeout);
}
function updateTimeout(timeout) {
    this.updateState({
        timeout: timeout
    });
}
function getTopOffset() {
    var topOffset = this.getState().topOffset;
    return topOffset;
}
function getLeftOffset() {
    var leftOffset = this.getState().leftOffset;
    return leftOffset;
}
function getStartMouseTop() {
    var startMouseTop = this.getState().startMouseTop;
    return startMouseTop;
}
function getStartMouseLeft() {
    var startMouseLeft = this.getState().startMouseLeft;
    return startMouseLeft;
}
function setTopOffset(topOffset) {
    this.updateState({
        topOffset: topOffset
    });
}
function setLeftOffset(leftOffset) {
    this.updateState({
        leftOffset: leftOffset
    });
}
function setStartMouseTop(startMouseTop) {
    this.updateState({
        startMouseTop: startMouseTop
    });
}
function setStartMouseLeft(startMouseLeft) {
    this.updateState({
        startMouseLeft: startMouseLeft
    });
}
function callHandlers(eventType) {
    for(var _len = arguments.length, remainingArguments = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){
        remainingArguments[_key - 1] = arguments[_key];
    }
    var _this = this;
    var eventListeners = this.findEventListeners(eventType);
    eventListeners.forEach(function(eventListener) {
        var _handler;
        var handler = eventListener.handler, handlerElement = eventListener.element, element = _this; ///
        (_handler = handler).call.apply(_handler, [
            handlerElement
        ].concat(_to_consumable_array(remainingArguments), [
            element
        ]));
    });
}
function callHandlersAsync(eventType) {
    for(var _len = arguments.length, remainingArguments = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){
        remainingArguments[_key - 1] = arguments[_key];
    }
    var _this = this;
    var done = remainingArguments.pop(), eventListeners = this.findEventListeners(eventType);
    forEach(eventListeners, function(eventListener, next) {
        var _handler;
        var handler = eventListener.handler, handlerElement = eventListener.element, element = _this, done = next; ///
        (_handler = handler).call.apply(_handler, [
            handlerElement
        ].concat(_to_consumable_array(remainingArguments), [
            element,
            done
        ]));
    }, done);
}
var _default = {
    onDrag: onDrag,
    offDrag: offDrag,
    onStopDrag: onStopDrag,
    offStopDrag: offStopDrag,
    onStartDrag: onStartDrag,
    offStartDrag: offStartDrag,
    enableDrag: enableDrag,
    disableDrag: disableDrag,
    isDragging: isDragging,
    startWaitingToDrag: startWaitingToDrag,
    stopWaitingToDrag: stopWaitingToDrag,
    startDrag: startDrag,
    stopDrag: stopDrag,
    drag: drag,
    getTimeout: getTimeout,
    resetTimeout: resetTimeout,
    updateTimeout: updateTimeout,
    getTopOffset: getTopOffset,
    getLeftOffset: getLeftOffset,
    getStartMouseTop: getStartMouseTop,
    getStartMouseLeft: getStartMouseLeft,
    setTopOffset: setTopOffset,
    setLeftOffset: setLeftOffset,
    setStartMouseTop: setStartMouseTop,
    setStartMouseLeft: setStartMouseLeft,
    callHandlers: callHandlers,
    callHandlersAsync: callHandlersAsync
};
function keyDownHandler(event, element) {
    var keyCode = event.keyCode, escapeKey = keyCode === ESCAPE_KEY_CODE, aborted = true;
    if (escapeKey) {
        this.stopDrag(aborted);
        event.stopPropagation();
    }
}
function mouseUpHandler(event, element) {
    var dragging = this.isDragging(), aborted = false;
    dragging ? this.stopDrag(aborted) : this.stopWaitingToDrag();
    event.stopPropagation();
    _easy.window.off(BLUR_EVENT_TYPE, mouseUpHandler, this); ///
    _easy.window.offMouseUp(mouseUpHandler, this);
}
function mouseDownHandler(event, element) {
    var button = event.button;
    if (button === LEFT_MOUSE_BUTTON) {
        var dragging = this.isDragging();
        if (!dragging) {
            var mouseTop = (0, _event.mouseTopFromEvent)(event), mouseLeft = (0, _event.mouseLeftFromEvent)(event);
            this.startWaitingToDrag(mouseTop, mouseLeft);
        }
    }
    event.stopPropagation();
    _easy.window.on(BLUR_EVENT_TYPE, mouseUpHandler, this); ///
    _easy.window.onMouseUp(mouseUpHandler, this);
}
function mouseMoveHandler(event, element) {
    var dragging = this.isDragging();
    if (dragging) {
        var mouseTop = (0, _event.mouseTopFromEvent)(event), mouseLeft = (0, _event.mouseLeftFromEvent)(event);
        this.drag(mouseTop, mouseLeft);
    }
    event.stopPropagation();
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9taXhpbnMvZHJhZy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsga2V5Q29kZXMsIGFzeW5jaHJvbm91c1V0aWxpdGllcyB9IGZyb20gXCJuZWNlc3NhcnlcIiA7XG5pbXBvcnQgeyB3aW5kb3csIGV2ZW50VHlwZXMsIG1vdXNlQnV0dG9ucyB9IGZyb20gXCJlYXN5XCI7XG5cbmltcG9ydCB7IFNUQVJUX0RSQUdHSU5HX0RFTEFZIH0gZnJvbSBcIi4uL2NvbnN0YW50c1wiO1xuaW1wb3J0IHsgY2hlY2tEcmFnRWxlbWVudElnbm9yZXNEcm9wRWxlbWVudCB9IGZyb20gXCIuLi91dGlsaXRpZXMvcmVmZXJlbmNlXCI7XG5pbXBvcnQgeyBtb3VzZVRvcEZyb21FdmVudCwgbW91c2VMZWZ0RnJvbUV2ZW50IH0gZnJvbSBcIi4uL3V0aWxpdGllcy9ldmVudFwiO1xuaW1wb3J0IHsgRFJBR19FVkVOVF9UWVBFLCBTVE9QX0RSQUdfRVZFTlRfVFlQRSwgU1RBUlRfRFJBR19FVkVOVF9UWVBFIH0gZnJvbSBcIi4uL2V2ZW50VHlwZXNcIjtcblxuY29uc3QgeyBmb3JFYWNoIH0gPSBhc3luY2hyb25vdXNVdGlsaXRpZXMsXG4gICAgICB7IEVTQ0FQRV9LRVlfQ09ERSB9ID0ga2V5Q29kZXMsXG4gICAgICB7IEJMVVJfRVZFTlRfVFlQRSB9ID0gZXZlbnRUeXBlcyxcbiAgICAgIHsgTEVGVF9NT1VTRV9CVVRUT04gfSA9IG1vdXNlQnV0dG9ucztcblxuY29uc3QgZHJhZ0VsZW1lbnQgPSBudWxsO1xuXG5PYmplY3QuYXNzaWduKGdsb2JhbFRoaXMsIHtcbiAgZHJhZ0VsZW1lbnRcbn0pO1xuXG5mdW5jdGlvbiBvbkRyYWcoZHJhZ0hhbmRsZXIsIGVsZW1lbnQpIHtcbiAgY29uc3QgZXZlbnRUeXBlID0gRFJBR19FVkVOVF9UWVBFLFxuICAgICAgICBoYW5kbGVyID0gZHJhZ0hhbmRsZXI7ICAvLy9cblxuICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnRUeXBlLCBoYW5kbGVyLCBlbGVtZW50KTtcbn1cblxuZnVuY3Rpb24gb2ZmRHJhZyhkcmFnSGFuZGxlciwgZWxlbWVudCkge1xuICBjb25zdCBldmVudFR5cGUgPSBEUkFHX0VWRU5UX1RZUEUsXG4gICAgICAgIGhhbmRsZXIgPSBkcmFnSGFuZGxlcjsgIC8vL1xuXG4gIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudFR5cGUsIGhhbmRsZXIsIGVsZW1lbnQpO1xufVxuXG5mdW5jdGlvbiBvblN0b3BEcmFnKHN0b3BEcmFnSGFuZGxlciwgZWxlbWVudCkge1xuICBjb25zdCBldmVudFR5cGUgPSBTVE9QX0RSQUdfRVZFTlRfVFlQRSxcbiAgICAgICAgaGFuZGxlciA9IHN0b3BEcmFnSGFuZGxlcjsgIC8vL1xuXG4gIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcihldmVudFR5cGUsIGhhbmRsZXIsIGVsZW1lbnQpO1xufVxuXG5mdW5jdGlvbiBvZmZTdG9wRHJhZyhzdG9wRHJhZ0hhbmRsZXIsIGVsZW1lbnQpIHtcbiAgY29uc3QgZXZlbnRUeXBlID0gU1RPUF9EUkFHX0VWRU5UX1RZUEUsXG4gICAgICAgIGhhbmRsZXIgPSBzdG9wRHJhZ0hhbmRsZXI7ICAvLy9cblxuICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnRUeXBlLCBoYW5kbGVyLCBlbGVtZW50KTtcbn1cblxuZnVuY3Rpb24gb25TdGFydERyYWcoc3RhcnREcmFnSGFuZGxlciwgZWxlbWVudCkge1xuICBjb25zdCBldmVudFR5cGUgPSBTVEFSVF9EUkFHX0VWRU5UX1RZUEUsXG4gICAgICAgIGhhbmRsZXIgPSBzdGFydERyYWdIYW5kbGVyOyAgLy8vXG5cbiAgdGhpcy5hZGRFdmVudExpc3RlbmVyKGV2ZW50VHlwZSwgaGFuZGxlciwgZWxlbWVudCk7XG59XG5cbmZ1bmN0aW9uIG9mZlN0YXJ0RHJhZyhzdGFydERyYWdIYW5kbGVyLCBlbGVtZW50KSB7XG4gIGNvbnN0IGV2ZW50VHlwZSA9IFNUQVJUX0RSQUdfRVZFTlRfVFlQRSxcbiAgICAgICAgaGFuZGxlciA9IHN0YXJ0RHJhZ0hhbmRsZXI7ICAvLy9cblxuICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnRUeXBlLCBoYW5kbGVyLCBlbGVtZW50KTtcbn1cblxuZnVuY3Rpb24gZW5hYmxlRHJhZygpIHtcbiAgY29uc3QgeyBvbkRyYWcsIG9uU3RvcERyYWcsIG9uU3RhcnREcmFnIH0gPSB0aGlzLnByb3BlcnRpZXMsXG4gICAgICAgIGRyYWdIYW5kbGVyID0gb25EcmFnLCAvLy9cbiAgICAgICAgc3RvcERyYWdIYW5kbGVyID0gb25TdG9wRHJhZywgLy8vXG4gICAgICAgIHN0YXJ0RHJhZ0hhbmRsZXIgPSBvblN0YXJ0RHJhZywgLy8vXG4gICAgICAgIHRpbWVvdXQgPSBudWxsLFxuICAgICAgICB0b3BPZmZzZXQgPSBudWxsLFxuICAgICAgICBsZWZ0T2Zmc2V0ID0gbnVsbCxcbiAgICAgICAgc3RhcnRNb3VzZVRvcCA9IG51bGwsXG4gICAgICAgIHN0YXJ0TW91c2VMZWZ0ID0gbnVsbDtcblxuICBkcmFnSGFuZGxlciAmJiB0aGlzLm9uRHJhZyhkcmFnSGFuZGxlcik7XG4gIHN0b3BEcmFnSGFuZGxlciAmJiB0aGlzLm9uU3RvcERyYWcoc3RvcERyYWdIYW5kbGVyKTtcbiAgc3RhcnREcmFnSGFuZGxlciAmJiB0aGlzLm9uU3RhcnREcmFnKHN0YXJ0RHJhZ0hhbmRsZXIpO1xuXG4gIHRoaXMub25Nb3VzZURvd24obW91c2VEb3duSGFuZGxlciwgdGhpcyk7XG5cbiAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgdGltZW91dCxcbiAgICB0b3BPZmZzZXQsXG4gICAgbGVmdE9mZnNldCxcbiAgICBzdGFydE1vdXNlVG9wLFxuICAgIHN0YXJ0TW91c2VMZWZ0XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBkaXNhYmxlRHJhZygpIHtcbiAgY29uc3QgeyBvbkRyYWcsIG9uU3RvcERyYWcsIG9uU3RhcnREcmFnIH0gPSB0aGlzLnByb3BlcnRpZXMsXG4gICAgICAgIGRyYWdIYW5kbGVyID0gb25EcmFnLCAvLy9cbiAgICAgICAgc3RvcERyYWdIYW5kbGVyID0gb25TdG9wRHJhZywgLy8vXG4gICAgICAgIHN0YXJ0RHJhZ0hhbmRsZXIgPSBvblN0YXJ0RHJhZzsgLy8vXG5cbiAgZHJhZ0hhbmRsZXIgJiYgdGhpcy5vZmZEcmFnKGRyYWdIYW5kbGVyKTtcbiAgc3RvcERyYWdIYW5kbGVyICYmIHRoaXMub2ZmU3RvcERyYWcoc3RvcERyYWdIYW5kbGVyKTtcbiAgc3RhcnREcmFnSGFuZGxlciAmJiB0aGlzLm9mZlN0YXJ0RHJhZyhzdGFydERyYWdIYW5kbGVyKTtcblxuICB0aGlzLm9mZk1vdXNlRG93bihtb3VzZURvd25IYW5kbGVyLCB0aGlzKTtcbn1cblxuZnVuY3Rpb24gaXNEcmFnZ2luZygpIHtcbiAgY29uc3QgZHJhZ2dpbmcgPSB0aGlzLmhhc0NsYXNzKFwiZHJhZ2dpbmdcIik7XG5cbiAgcmV0dXJuIGRyYWdnaW5nO1xufVxuXG5mdW5jdGlvbiBzdGFydFdhaXRpbmdUb0RyYWcobW91c2VUb3AsIG1vdXNlTGVmdCkge1xuICBsZXQgdGltZW91dCA9IHRoaXMuZ2V0VGltZW91dCgpO1xuXG4gIGlmICh0aW1lb3V0ID09PSBudWxsKSB7XG4gICAgdGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy5yZXNldFRpbWVvdXQoKTtcblxuICAgICAgdGhpcy5zdGFydERyYWcobW91c2VUb3AsIG1vdXNlTGVmdCk7XG4gICAgfSwgU1RBUlRfRFJBR0dJTkdfREVMQVkpO1xuXG4gICAgdGhpcy51cGRhdGVUaW1lb3V0KHRpbWVvdXQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHN0b3BXYWl0aW5nVG9EcmFnKCkge1xuICBjb25zdCB0aW1lb3V0ID0gdGhpcy5nZXRUaW1lb3V0KCk7XG5cbiAgaWYgKHRpbWVvdXQgIT09IG51bGwpIHtcbiAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG5cbiAgICB0aGlzLnJlc2V0VGltZW91dCgpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHN0YXJ0RHJhZyhtb3VzZVRvcCwgbW91c2VMZWZ0KSB7XG4gIGNvbnN0IGJvdW5kcyA9IHRoaXMuZ2V0Qm91bmRzKCksXG4gICAgICAgIGV2ZW50VHlwZSA9IFNUQVJUX0RSQUdfRVZFTlRfVFlQRSxcbiAgICAgICAgYm91bmRzVG9wID0gYm91bmRzLmdldFRvcCgpLFxuICAgICAgICBib3VuZHNMZWZ0ID0gYm91bmRzLmdldExlZnQoKSxcbiAgICAgICAgYm91bmRzUmlnaHQgPSBib3VuZHMuZ2V0UmlnaHQoKSxcbiAgICAgICAgYm91bmRzQm90dG9tID0gYm91bmRzLmdldEJvdHRvbSgpLFxuICAgICAgICBib3VuZHNXaWR0aCA9IGJvdW5kc1JpZ2h0IC0gYm91bmRzTGVmdCxcbiAgICAgICAgYm91bmRzSGVpZ2h0ID0gYm91bmRzQm90dG9tIC0gYm91bmRzVG9wLFxuICAgICAgICB0b3BPZmZzZXQgPSBNYXRoLmZsb29yKGJvdW5kc0hlaWdodCAvIDIpLFxuICAgICAgICBsZWZ0T2Zmc2V0ID0gTWF0aC5mbG9vcihib3VuZHNXaWR0aCAvIDIpLFxuICAgICAgICBkcmFnRWxlbWVudCA9IHRoaXMsIC8vL1xuICAgICAgICBzdGFydE1vdXNlVG9wID0gbW91c2VUb3AsIC8vL1xuICAgICAgICBzdGFydE1vdXNlTGVmdCA9IG1vdXNlTGVmdDsgLy8vXG5cbiAgd2luZG93Lm9uS2V5RG93bihrZXlEb3duSGFuZGxlciwgdGhpcyk7XG5cbiAgd2luZG93Lm9uTW91c2VNb3ZlKG1vdXNlTW92ZUhhbmRsZXIsIHRoaXMpO1xuXG4gIHRoaXMuYWRkQ2xhc3MoXCJkcmFnZ2luZ1wiKTtcblxuICBPYmplY3QuYXNzaWduKGdsb2JhbFRoaXMsIHtcbiAgICBkcmFnRWxlbWVudFxuICB9KTtcblxuICB0aGlzLnNldFRvcE9mZnNldCh0b3BPZmZzZXQpO1xuXG4gIHRoaXMuc2V0TGVmdE9mZnNldChsZWZ0T2Zmc2V0KTtcblxuICB0aGlzLnNldFN0YXJ0TW91c2VUb3Aoc3RhcnRNb3VzZVRvcCk7XG5cbiAgdGhpcy5zZXRTdGFydE1vdXNlTGVmdChzdGFydE1vdXNlTGVmdCk7XG5cbiAgdGhpcy5jYWxsSGFuZGxlcnMoZXZlbnRUeXBlKTtcblxuICB0aGlzLmRyYWcobW91c2VUb3AsIG1vdXNlTGVmdCk7XG59XG5cbmZ1bmN0aW9uIHN0b3BEcmFnKGFib3J0ZWQpIHtcbiAgY29uc3QgeyBkcm9wRWxlbWVudCB9ID0gZ2xvYmFsVGhpcyxcbiAgICAgICAgZXZlbnRUeXBlID0gU1RPUF9EUkFHX0VWRU5UX1RZUEU7XG5cbiAgd2luZG93Lm9mZktleURvd24oa2V5RG93bkhhbmRsZXIsIHRoaXMpO1xuXG4gIHdpbmRvdy5vZmZNb3VzZU1vdmUobW91c2VNb3ZlSGFuZGxlciwgdGhpcyk7XG5cbiAgY29uc3QgZG9uZSA9ICgpID0+IHtcbiAgICB0aGlzLmNhbGxIYW5kbGVyc0FzeW5jKGV2ZW50VHlwZSwgZHJvcEVsZW1lbnQsIGFib3J0ZWQsICgpID0+IHtcbiAgICAgIGNvbnN0IGRyYWdFbGVtZW50ID0gbnVsbDtcblxuICAgICAgT2JqZWN0LmFzc2lnbihnbG9iYWxUaGlzLCB7XG4gICAgICAgIGRyYWdFbGVtZW50XG4gICAgICB9KTtcblxuICAgICAgdGhpcy5yZW1vdmVDbGFzcyhcImRyYWdnaW5nXCIpO1xuICAgIH0pO1xuICB9XG5cbiAgaWYgKGRyb3BFbGVtZW50ICE9PSBudWxsKSB7XG4gICAgbGV0IGRyYWdFbGVtZW50ID0gdGhpczsgLy8vXG5cbiAgICBjb25zdCBkcmFnRWxlbWVudElnbm9yZXNEcm9wRWxlbWVudCA9IGNoZWNrRHJhZ0VsZW1lbnRJZ25vcmVzRHJvcEVsZW1lbnQoZHJhZ0VsZW1lbnQsIGRyb3BFbGVtZW50KTtcblxuICAgIGlmIChkcmFnRWxlbWVudElnbm9yZXNEcm9wRWxlbWVudCkge1xuICAgICAgZHJhZ0VsZW1lbnQgPSBudWxsO1xuICAgIH1cblxuICAgIGRyb3BFbGVtZW50LmRyb3AoZHJhZ0VsZW1lbnQsIGFib3J0ZWQsIGRvbmUpO1xuICB9IGVsc2Uge1xuICAgIGRvbmUoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBkcmFnKG1vdXNlVG9wLCBtb3VzZUxlZnQpIHtcbiAgY29uc3QgZXZlbnRUeXBlID0gRFJBR19FVkVOVF9UWVBFLFxuICAgICAgICBzY3JvbGxUb3AgPSB3aW5kb3cuZ2V0U2Nyb2xsVG9wKCksXG4gICAgICAgIHNjcm9sbExlZnQgPSB3aW5kb3cuZ2V0U2Nyb2xsTGVmdCgpLFxuICAgICAgICB0b3BPZmZzZXQgPSB0aGlzLmdldFRvcE9mZnNldCgpLFxuICAgICAgICBsZWZ0T2Zmc2V0ID0gdGhpcy5nZXRMZWZ0T2Zmc2V0KCksXG4gICAgICAgIHN0YXJ0TW91c2VUb3AgPSB0aGlzLmdldFN0YXJ0TW91c2VUb3AoKSxcbiAgICAgICAgc3RhcnRNb3VzZUxlZnQgPSB0aGlzLmdldFN0YXJ0TW91c2VMZWZ0KCksXG4gICAgICAgIHJlbGF0aXZlTW91c2VUb3AgPSBtb3VzZVRvcCAtIHN0YXJ0TW91c2VUb3AsXG4gICAgICAgIHJlbGF0aXZlTW91c2VMZWZ0ID0gbW91c2VMZWZ0IC0gc3RhcnRNb3VzZUxlZnQ7XG5cbiAgbGV0IHRvcCA9IHN0YXJ0TW91c2VUb3AgKyByZWxhdGl2ZU1vdXNlVG9wIC0gdG9wT2Zmc2V0IC0gc2Nyb2xsVG9wLFxuICAgICAgbGVmdCA9IHN0YXJ0TW91c2VMZWZ0ICsgcmVsYXRpdmVNb3VzZUxlZnQgLSBsZWZ0T2Zmc2V0IC0gc2Nyb2xsTGVmdDtcblxuICB0b3AgPSBgJHt0b3B9cHhgOyAvLy9cbiAgbGVmdCA9IGAke2xlZnR9cHhgOyAvLy9cblxuICBjb25zdCBjc3MgPSB7XG4gICAgdG9wLFxuICAgIGxlZnRcbiAgfTtcblxuICB0aGlzLmNzcyhjc3MpO1xuXG4gIHRoaXMuY2FsbEhhbmRsZXJzKGV2ZW50VHlwZSwgcmVsYXRpdmVNb3VzZVRvcCwgcmVsYXRpdmVNb3VzZUxlZnQpO1xufVxuXG5mdW5jdGlvbiBnZXRUaW1lb3V0KCkge1xuICBjb25zdCB7IHRpbWVvdXQgfSA9IHRoaXMuZ2V0U3RhdGUoKTtcblxuICByZXR1cm4gdGltZW91dDtcbn1cblxuZnVuY3Rpb24gcmVzZXRUaW1lb3V0KCkge1xuICBjb25zdCB0aW1lb3V0ID0gbnVsbDtcblxuICB0aGlzLnVwZGF0ZVRpbWVvdXQodGltZW91dCk7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZVRpbWVvdXQodGltZW91dCkge1xuICB0aGlzLnVwZGF0ZVN0YXRlKHtcbiAgICB0aW1lb3V0XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBnZXRUb3BPZmZzZXQoKSB7XG4gIGNvbnN0IHsgdG9wT2Zmc2V0IH0gPSB0aGlzLmdldFN0YXRlKCk7XG5cbiAgcmV0dXJuIHRvcE9mZnNldDtcbn1cblxuZnVuY3Rpb24gZ2V0TGVmdE9mZnNldCgpIHtcbiAgY29uc3QgeyBsZWZ0T2Zmc2V0IH0gPSB0aGlzLmdldFN0YXRlKCk7XG5cbiAgcmV0dXJuIGxlZnRPZmZzZXQ7XG59XG5cbmZ1bmN0aW9uIGdldFN0YXJ0TW91c2VUb3AoKSB7XG4gIGNvbnN0IHsgc3RhcnRNb3VzZVRvcCB9ID0gdGhpcy5nZXRTdGF0ZSgpO1xuXG4gIHJldHVybiBzdGFydE1vdXNlVG9wO1xufVxuXG5mdW5jdGlvbiBnZXRTdGFydE1vdXNlTGVmdCgpIHtcbiAgY29uc3QgeyBzdGFydE1vdXNlTGVmdCB9ID0gdGhpcy5nZXRTdGF0ZSgpO1xuXG4gIHJldHVybiBzdGFydE1vdXNlTGVmdDtcbn1cblxuZnVuY3Rpb24gc2V0VG9wT2Zmc2V0KHRvcE9mZnNldCkge1xuICB0aGlzLnVwZGF0ZVN0YXRlKHtcbiAgICB0b3BPZmZzZXRcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHNldExlZnRPZmZzZXQobGVmdE9mZnNldCkge1xuICB0aGlzLnVwZGF0ZVN0YXRlKHtcbiAgICBsZWZ0T2Zmc2V0XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBzZXRTdGFydE1vdXNlVG9wKHN0YXJ0TW91c2VUb3ApIHtcbiAgdGhpcy51cGRhdGVTdGF0ZSh7XG4gICAgc3RhcnRNb3VzZVRvcFxuICB9KTtcbn1cblxuZnVuY3Rpb24gc2V0U3RhcnRNb3VzZUxlZnQoc3RhcnRNb3VzZUxlZnQpIHtcbiAgdGhpcy51cGRhdGVTdGF0ZSh7XG4gICAgc3RhcnRNb3VzZUxlZnRcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGNhbGxIYW5kbGVycyhldmVudFR5cGUsIC4uLnJlbWFpbmluZ0FyZ3VtZW50cykge1xuICBjb25zdCBldmVudExpc3RlbmVycyA9IHRoaXMuZmluZEV2ZW50TGlzdGVuZXJzKGV2ZW50VHlwZSk7XG5cbiAgZXZlbnRMaXN0ZW5lcnMuZm9yRWFjaCgoZXZlbnRMaXN0ZW5lcikgPT4ge1xuICAgIGNvbnN0IHsgaGFuZGxlciwgZWxlbWVudDogaGFuZGxlckVsZW1lbnQgfSA9IGV2ZW50TGlzdGVuZXIsXG4gICAgICAgICAgZWxlbWVudCA9IHRoaXM7IC8vL1xuXG4gICAgaGFuZGxlci5jYWxsKGhhbmRsZXJFbGVtZW50LCAuLi5yZW1haW5pbmdBcmd1bWVudHMsIGVsZW1lbnQpO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gY2FsbEhhbmRsZXJzQXN5bmMoZXZlbnRUeXBlLCAuLi5yZW1haW5pbmdBcmd1bWVudHMpIHtcbiAgY29uc3QgZG9uZSA9IHJlbWFpbmluZ0FyZ3VtZW50cy5wb3AoKSwgIC8vL1xuICAgICAgICBldmVudExpc3RlbmVycyA9IHRoaXMuZmluZEV2ZW50TGlzdGVuZXJzKGV2ZW50VHlwZSk7XG5cbiAgZm9yRWFjaChldmVudExpc3RlbmVycywgKGV2ZW50TGlzdGVuZXIsIG5leHQpID0+IHtcbiAgICBjb25zdCB7IGhhbmRsZXIsIGVsZW1lbnQ6IGhhbmRsZXJFbGVtZW50IH0gPSBldmVudExpc3RlbmVyLFxuICAgICAgICAgIGVsZW1lbnQgPSB0aGlzLCAvLy9cbiAgICAgICAgICBkb25lID0gbmV4dDsgIC8vL1xuXG4gICAgaGFuZGxlci5jYWxsKGhhbmRsZXJFbGVtZW50LCAuLi5yZW1haW5pbmdBcmd1bWVudHMsIGVsZW1lbnQsIGRvbmUpO1xuICB9LCBkb25lKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQge1xuICBvbkRyYWcsXG4gIG9mZkRyYWcsXG4gIG9uU3RvcERyYWcsXG4gIG9mZlN0b3BEcmFnLFxuICBvblN0YXJ0RHJhZyxcbiAgb2ZmU3RhcnREcmFnLFxuICBlbmFibGVEcmFnLFxuICBkaXNhYmxlRHJhZyxcbiAgaXNEcmFnZ2luZyxcbiAgc3RhcnRXYWl0aW5nVG9EcmFnLFxuICBzdG9wV2FpdGluZ1RvRHJhZyxcbiAgc3RhcnREcmFnLFxuICBzdG9wRHJhZyxcbiAgZHJhZyxcbiAgZ2V0VGltZW91dCxcbiAgcmVzZXRUaW1lb3V0LFxuICB1cGRhdGVUaW1lb3V0LFxuICBnZXRUb3BPZmZzZXQsXG4gIGdldExlZnRPZmZzZXQsXG4gIGdldFN0YXJ0TW91c2VUb3AsXG4gIGdldFN0YXJ0TW91c2VMZWZ0LFxuICBzZXRUb3BPZmZzZXQsXG4gIHNldExlZnRPZmZzZXQsXG4gIHNldFN0YXJ0TW91c2VUb3AsXG4gIHNldFN0YXJ0TW91c2VMZWZ0LFxuICBjYWxsSGFuZGxlcnMsXG4gIGNhbGxIYW5kbGVyc0FzeW5jXG59O1xuXG5mdW5jdGlvbiBrZXlEb3duSGFuZGxlcihldmVudCwgZWxlbWVudCkge1xuICBjb25zdCB7IGtleUNvZGUgfSA9IGV2ZW50LFxuICAgICAgICBlc2NhcGVLZXkgPSAoa2V5Q29kZSA9PT0gRVNDQVBFX0tFWV9DT0RFKSxcbiAgICAgICAgYWJvcnRlZCA9IHRydWU7XG5cbiAgaWYgKGVzY2FwZUtleSkge1xuICAgIHRoaXMuc3RvcERyYWcoYWJvcnRlZCk7XG5cbiAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBtb3VzZVVwSGFuZGxlcihldmVudCwgZWxlbWVudCkge1xuICBjb25zdCBkcmFnZ2luZyA9IHRoaXMuaXNEcmFnZ2luZygpLFxuICAgICAgICBhYm9ydGVkID0gZmFsc2U7XG5cbiAgZHJhZ2dpbmcgP1xuICAgIHRoaXMuc3RvcERyYWcoYWJvcnRlZCkgOlxuICAgICAgdGhpcy5zdG9wV2FpdGluZ1RvRHJhZygpO1xuXG4gIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXG4gIHdpbmRvdy5vZmYoQkxVUl9FVkVOVF9UWVBFLCBtb3VzZVVwSGFuZGxlciwgdGhpcyk7ICAvLy9cblxuICB3aW5kb3cub2ZmTW91c2VVcChtb3VzZVVwSGFuZGxlciwgdGhpcyk7XG59XG5cbmZ1bmN0aW9uIG1vdXNlRG93bkhhbmRsZXIoZXZlbnQsIGVsZW1lbnQpIHtcbiAgY29uc3QgeyBidXR0b24gfSA9IGV2ZW50O1xuXG4gIGlmIChidXR0b24gPT09IExFRlRfTU9VU0VfQlVUVE9OKSB7XG4gICAgY29uc3QgZHJhZ2dpbmcgPSB0aGlzLmlzRHJhZ2dpbmcoKTtcblxuICAgIGlmICghZHJhZ2dpbmcpIHtcbiAgICAgIGNvbnN0IG1vdXNlVG9wID0gbW91c2VUb3BGcm9tRXZlbnQoZXZlbnQpLFxuICAgICAgICAgICAgbW91c2VMZWZ0ID0gbW91c2VMZWZ0RnJvbUV2ZW50KGV2ZW50KTtcblxuICAgICAgdGhpcy5zdGFydFdhaXRpbmdUb0RyYWcobW91c2VUb3AsIG1vdXNlTGVmdCk7XG4gICAgfVxuICB9XG5cbiAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG5cbiAgd2luZG93Lm9uKEJMVVJfRVZFTlRfVFlQRSwgbW91c2VVcEhhbmRsZXIsIHRoaXMpOyAvLy9cblxuICB3aW5kb3cub25Nb3VzZVVwKG1vdXNlVXBIYW5kbGVyLCB0aGlzKTtcbn1cblxuZnVuY3Rpb24gbW91c2VNb3ZlSGFuZGxlcihldmVudCwgZWxlbWVudCkge1xuICBjb25zdCBkcmFnZ2luZyA9IHRoaXMuaXNEcmFnZ2luZygpO1xuXG4gIGlmIChkcmFnZ2luZykge1xuICAgIGNvbnN0IG1vdXNlVG9wID0gbW91c2VUb3BGcm9tRXZlbnQoZXZlbnQpLFxuICAgICAgICAgIG1vdXNlTGVmdCA9IG1vdXNlTGVmdEZyb21FdmVudChldmVudCk7XG5cbiAgICB0aGlzLmRyYWcobW91c2VUb3AsIG1vdXNlTGVmdCk7XG4gIH1cblxuICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbn1cbiJdLCJuYW1lcyI6WyJmb3JFYWNoIiwiYXN5bmNocm9ub3VzVXRpbGl0aWVzIiwiRVNDQVBFX0tFWV9DT0RFIiwia2V5Q29kZXMiLCJCTFVSX0VWRU5UX1RZUEUiLCJldmVudFR5cGVzIiwiTEVGVF9NT1VTRV9CVVRUT04iLCJtb3VzZUJ1dHRvbnMiLCJkcmFnRWxlbWVudCIsIk9iamVjdCIsImFzc2lnbiIsImdsb2JhbFRoaXMiLCJvbkRyYWciLCJkcmFnSGFuZGxlciIsImVsZW1lbnQiLCJldmVudFR5cGUiLCJEUkFHX0VWRU5UX1RZUEUiLCJoYW5kbGVyIiwiYWRkRXZlbnRMaXN0ZW5lciIsIm9mZkRyYWciLCJyZW1vdmVFdmVudExpc3RlbmVyIiwib25TdG9wRHJhZyIsInN0b3BEcmFnSGFuZGxlciIsIlNUT1BfRFJBR19FVkVOVF9UWVBFIiwib2ZmU3RvcERyYWciLCJvblN0YXJ0RHJhZyIsInN0YXJ0RHJhZ0hhbmRsZXIiLCJTVEFSVF9EUkFHX0VWRU5UX1RZUEUiLCJvZmZTdGFydERyYWciLCJlbmFibGVEcmFnIiwicHJvcGVydGllcyIsInRpbWVvdXQiLCJ0b3BPZmZzZXQiLCJsZWZ0T2Zmc2V0Iiwic3RhcnRNb3VzZVRvcCIsInN0YXJ0TW91c2VMZWZ0Iiwib25Nb3VzZURvd24iLCJtb3VzZURvd25IYW5kbGVyIiwic2V0U3RhdGUiLCJkaXNhYmxlRHJhZyIsIm9mZk1vdXNlRG93biIsImlzRHJhZ2dpbmciLCJkcmFnZ2luZyIsImhhc0NsYXNzIiwic3RhcnRXYWl0aW5nVG9EcmFnIiwibW91c2VUb3AiLCJtb3VzZUxlZnQiLCJnZXRUaW1lb3V0Iiwic2V0VGltZW91dCIsInJlc2V0VGltZW91dCIsInN0YXJ0RHJhZyIsIlNUQVJUX0RSQUdHSU5HX0RFTEFZIiwidXBkYXRlVGltZW91dCIsInN0b3BXYWl0aW5nVG9EcmFnIiwiY2xlYXJUaW1lb3V0IiwiYm91bmRzIiwiZ2V0Qm91bmRzIiwiYm91bmRzVG9wIiwiZ2V0VG9wIiwiYm91bmRzTGVmdCIsImdldExlZnQiLCJib3VuZHNSaWdodCIsImdldFJpZ2h0IiwiYm91bmRzQm90dG9tIiwiZ2V0Qm90dG9tIiwiYm91bmRzV2lkdGgiLCJib3VuZHNIZWlnaHQiLCJNYXRoIiwiZmxvb3IiLCJ3aW5kb3ciLCJvbktleURvd24iLCJrZXlEb3duSGFuZGxlciIsIm9uTW91c2VNb3ZlIiwibW91c2VNb3ZlSGFuZGxlciIsImFkZENsYXNzIiwic2V0VG9wT2Zmc2V0Iiwic2V0TGVmdE9mZnNldCIsInNldFN0YXJ0TW91c2VUb3AiLCJzZXRTdGFydE1vdXNlTGVmdCIsImNhbGxIYW5kbGVycyIsImRyYWciLCJzdG9wRHJhZyIsImFib3J0ZWQiLCJkcm9wRWxlbWVudCIsIm9mZktleURvd24iLCJvZmZNb3VzZU1vdmUiLCJkb25lIiwiY2FsbEhhbmRsZXJzQXN5bmMiLCJyZW1vdmVDbGFzcyIsImRyYWdFbGVtZW50SWdub3Jlc0Ryb3BFbGVtZW50IiwiY2hlY2tEcmFnRWxlbWVudElnbm9yZXNEcm9wRWxlbWVudCIsImRyb3AiLCJzY3JvbGxUb3AiLCJnZXRTY3JvbGxUb3AiLCJzY3JvbGxMZWZ0IiwiZ2V0U2Nyb2xsTGVmdCIsImdldFRvcE9mZnNldCIsImdldExlZnRPZmZzZXQiLCJnZXRTdGFydE1vdXNlVG9wIiwiZ2V0U3RhcnRNb3VzZUxlZnQiLCJyZWxhdGl2ZU1vdXNlVG9wIiwicmVsYXRpdmVNb3VzZUxlZnQiLCJ0b3AiLCJsZWZ0IiwiY3NzIiwiZ2V0U3RhdGUiLCJ1cGRhdGVTdGF0ZSIsInJlbWFpbmluZ0FyZ3VtZW50cyIsImV2ZW50TGlzdGVuZXJzIiwiZmluZEV2ZW50TGlzdGVuZXJzIiwiZXZlbnRMaXN0ZW5lciIsImhhbmRsZXJFbGVtZW50IiwiY2FsbCIsInBvcCIsIm5leHQiLCJldmVudCIsImtleUNvZGUiLCJlc2NhcGVLZXkiLCJzdG9wUHJvcGFnYXRpb24iLCJtb3VzZVVwSGFuZGxlciIsIm9mZiIsIm9mZk1vdXNlVXAiLCJidXR0b24iLCJtb3VzZVRvcEZyb21FdmVudCIsIm1vdXNlTGVm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